"""
Minimal sonification per USP 9,018,506 patent.
Maps atomic mass → pitch, electronegativity → timbre, bond polarity → amplitude.
"""
from rdkit import Chem
import numpy as np
import soundfile as sf
import os

# Electronegativity lookup (Pauling scale)
EN_VALUES = {
    'H': 2.20, 'C': 2.55, 'N': 3.04, 'O': 3.44, 'F': 3.98,
    'P': 2.19, 'S': 2.58, 'Cl': 3.16, 'Br': 2.96, 'I': 2.66,
    'Na': 0.93, 'K': 0.82, 'Ca': 1.00, 'Mg': 1.31, 'Li': 0.98
}

def get_electronegativity(symbol):
    return EN_VALUES.get(symbol, 2.0)

def smiles_to_wav(smiles: str, out_path: str, duration: float = 1.0):
    """Convert SMILES to audio waveform with chemically meaningful encoding."""
    mol = Chem.MolFromSmiles(smiles)
    if mol is None or mol.GetNumAtoms() == 0:
        # Invalid molecule → generate 1-second silence
        waveform = np.zeros(int(16000 * duration), dtype=np.float32)
        sf.write(out_path, waveform, 16000)
        return

    sample_rate = 16000
    total_samples = int(sample_rate * duration)
    waveform = np.zeros(total_samples, dtype=np.float32)
    
    atoms = list(mol.GetAtoms())
    n_atoms = len(atoms)
    
    # Allocate time slots for each atom (evenly spaced)
    atom_duration = duration / max(n_atoms, 1)
    
    for i, atom in enumerate(atoms):
        # Patent mapping: atomic mass → base frequency (20Hz-20kHz)
        mass = atom.GetMass()
        base_freq = 100 + (mass / 300) * 19900  # Scale to audible range
        
        # Patent mapping: electronegativity → harmonic complexity
        symbol = atom.GetSymbol()
        en = get_electronegativity(symbol)
        n_harmonics = max(1, min(8, int(en * 2)))
        
        # Generate atom "note" (harmonic series)
        note_samples = int(sample_rate * atom_duration * 0.8)  # 80% of slot
        t = np.linspace(0, atom_duration * 0.8, note_samples, endpoint=False)
        
        atom_wave = np.zeros(note_samples)
        for h in range(1, n_harmonics + 1):
            atom_wave += (1.0 / h) * np.sin(2 * np.pi * base_freq * h * t)
        
        # Patent mapping: bond polarity → amplitude envelope
        bonds = atom.GetBonds()
        avg_polarity = 0.5  # Default mid-polarity
        if bonds:
            polarities = []
            for bond in bonds:
                bt = bond.GetBondTypeAsDouble()
                # Crude polarity estimate: higher order = more polar for heteroatoms
                if atom.GetAtomicNum() != bond.GetOtherAtom(atom).GetAtomicNum():
                    polarities.append(min(1.0, bt * 0.7))
            if polarities:
                avg_polarity = np.mean(polarities)
        
        # Apply amplitude envelope (ADSR-like)
        amp_env = np.ones(note_samples)
        attack = int(note_samples * 0.1)
        release = int(note_samples * 0.3)
        amp_env[:attack] = np.linspace(0, 1, attack)
        amp_env[-release:] = np.linspace(1, 0, release)
        atom_wave *= amp_env * (0.3 + avg_polarity * 0.7)
        
        # Position in waveform
        start_idx = int(i * total_samples / n_atoms)
        end_idx = min(start_idx + note_samples, total_samples)
        
        # Mix into main waveform (with soft clipping prevention)
        waveform[start_idx:end_idx] += atom_wave[:end_idx-start_idx] * 0.5
    
    # Normalize to [-0.9, 0.9] to prevent clipping
    max_amp = np.max(np.abs(waveform))
    if max_amp > 0.01:
        waveform = waveform * 0.9 / max_amp
    
    # Save WAV file
    sf.write(out_path, waveform.astype(np.float32), sample_rate)

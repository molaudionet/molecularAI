# training/trainer.py — REPLACE ENTIRE FILE
"""
Minimal trainer for sklearn-based models (classification + regression).
NO PyTorch dependencies — single-shot training matches paper methodology.
"""
import numpy as np
from models.head import train_logreg_multitask, predict_proba
from training.metrics import classification_metrics, regression_metrics

def evaluate(model, X, Y, M, cfg):
    prob = predict_proba(model, X)
    per_task = {}
    label_cols = cfg["dataset"]["label_cols"]
    task_types = cfg.get("dataset", {}).get("task_types", {})
    for j, name in enumerate(label_cols):
        task_type = task_types.get(name, "classification")
        valid = M[:, j] > 0.5
        if not np.any(valid): continue
        if task_type == "regression":
            pred = prob[:, j]
            per_task[name] = regression_metrics(Y[valid, j], pred[valid], M[valid, j])
        else:
            per_task[name] = classification_metrics(Y[valid, j], prob[valid, j], M[valid, j])
    if not per_task: return {"tasks": {}, "macro": {}}
    all_metrics = set()
    for task_metrics in per_task.values():
        all_metrics.update(task_metrics.keys())
    macro = {}
    for metric in all_metrics:
        values = [m.get(metric, 0.0) for m in per_task.values() if metric in m]
        if values: macro[metric] = float(np.mean(values))
    return {"tasks": per_task, "macro": macro}

def fit(cfg, X, Y, M, splits):
    train_idx = splits["train"]
    val_idx = splits["val"]
    test_idx = splits["test"]

    # ✅ SINGLE-SHOT TRAINING (paper methodology)
    print("Training multi-task model...")
    model = train_logreg_multitask(
        X=X[train_idx],
        Y=Y[train_idx],
        M=M[train_idx],
        label_names=cfg["dataset"]["label_cols"],
        task_types=cfg.get("dataset", {}).get("task_types", {}),
        max_iter=cfg.get("train", {}).get("max_iter", 2000),
        min_n=cfg.get("train", {}).get("min_n", 10)
    )
    print("✓ Training complete")

    results = {
        "train": evaluate(model, X[train_idx], Y[train_idx], M[train_idx], cfg),
        "val": evaluate(model, X[val_idx], Y[val_idx], M[val_idx], cfg),
        "test": evaluate(model, X[test_idx], Y[test_idx], M[test_idx], cfg),
        "model": model,
    }

    # Print R² results
    print("\n" + "="*60)
    print("TRAINING COMPLETE")
    print("="*60)
    for split in ["train", "val", "test"]:
        r2 = results[split]["macro"].get("r2")
        if r2 is not None:
            status = "✅" if split=="test" and r2>=0.85 else ""
            print(f"{split.capitalize():<5} R²: {r2:.3f} {status}")
    print("="*60 + "\n")
    return results
